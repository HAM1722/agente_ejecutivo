# -*- coding: utf-8 -*-
"""
analizador.py ‚Äî Analiza facturas con LLM usando JSON estricto y bloques espec√≠ficos
"""

import os
import json
import re
import csv
from pathlib import Path
from dotenv import load_dotenv
from openai import OpenAI
from typing import Optional, List, Dict, Any, Tuple
import utils

# Forzar carga del .env desde la ra√≠z del proyecto
ENV_PATH = Path(__file__).resolve().parent.parent / ".env"
load_dotenv(dotenv_path=ENV_PATH, override=True)

API_KEY = os.getenv("OPENAI_API_KEY")
if not API_KEY:
    raise SystemExit("‚ùå No se encontr√≥ OPENAI_API_KEY en .env")

client = OpenAI(api_key=API_KEY)

def cargar_prompt_emcali() -> str:
    """
    Carga el prompt desde el archivo prompts/emcali_v1.txt
    """
    prompt_path = Path(__file__).parent.parent / "prompts" / "emcali_v1.txt"
    try:
        with open(prompt_path, 'r', encoding='utf-8') as f:
            return f.read().strip()
    except FileNotFoundError:
        raise FileNotFoundError(f"No se encontr√≥ el archivo de prompt: {prompt_path}")
    except Exception as e:
        raise Exception(f"Error al cargar el prompt: {e}")


def cargar_schema_emcali() -> Dict[str, Any]:
    """
    Carga el esquema JSON desde schemas/emcali_v1.json
    """
    schema_path = Path(__file__).parent.parent / "schemas" / "emcali_v1.json"
    try:
        with open(schema_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"No se encontr√≥ el archivo de esquema: {schema_path}")
    except Exception as e:
        raise Exception(f"Error al cargar el esquema: {e}")

# Esquema JSON estricto para la respuesta
RESPONSE_SCHEMA = {
    "cliente": {
        "nombre": "string",
        "direccion": "string", 
        "contrato": "string"
    },
    "periodo": {
        "desde": "string",
        "hasta": "string",
        "dias": "number"
    },
    "energia": {
        "activa_kwh": "number",
        "valor_unitario_cop_kwh": "number",
        "subtotal_energia_cop": "number"
    },
    "otros_servicios": {
        "aseo_cop": "number",
        "alumbrado_publico_cop": "number",
        "tasa_seguridad_cop": "number"
    },
    "total_pagar_cop": "number",
    "justificaciones": ["string"]
}

# Prompt de sistema estricto
SYSTEM_PROMPT = """Eres un extractor de datos de facturas EMCALI.
Tu tarea es extraer EXACTAMENTE los datos que aparecen en el PDF, sin inventar nada.

REGLAS ESTRICTAS:
1. SOLO extrae datos que est√©n EXPL√çCITAMENTE en el texto proporcionado
2. Si un dato no est√° presente, usa null o 0 seg√∫n corresponda
3. NO inventes valores, NO hagas c√°lculos, NO asumas nada
4. Los n√∫meros deben ser exactos como aparecen en la factura
5. Devuelve SOLO JSON v√°lido que cumpla el schema proporcionado

BUSCA ESPEC√çFICAMENTE ESTOS PATRONES:
- cliente.nombre: Busca "NESTOR ZULUAGA GOMEZ" o nombres similares
- cliente.direccion: Busca "CL 7 OESTE AV 1-70 ZC" o direcciones similares
- cliente.contrato: Busca "CONTRATO 46636472" o n√∫meros de contrato
- periodo.desde: Busca "MAR 26" o fechas de inicio
- periodo.hasta: Busca "ABR 24" o fechas de fin
- periodo.dias: Busca "D√≠as Facturados 30" o similar
- energia.activa_kwh: Busca "7,111" kWh o "Consumo Actual 7,111 KWH"
- energia.valor_unitario_cop_kwh: Busca "838.07" o "Valor Unitario"
- energia.subtotal_energia_cop: Busca "7,151,438.93" o "SubTotal Servicios EMCALI"
- otros_servicios.aseo_cop: Busca cargos por aseo
- otros_servicios.alumbrado_publico_cop: Busca "ALUMBRADO PUBLICO" y valores
- otros_servicios.tasa_seguridad_cop: Busca "TASA SEGURIDAD" y valores
- total_pagar_cop: Busca "TOTAL A PAGAR $ 8,004,574.00" o similar

IMPORTANTE: Si no encuentras un dato, pon null/0 y explica en justificaciones por qu√© no se pudo extraer."""


def extraer_bloques_relevantes(texto_completo: str) -> Dict[str, str]:
    """
    Extrae solo los bloques relevantes del texto del PDF.
    
    Args:
        texto_completo: Texto completo extra√≠do del PDF
        
    Returns:
        Diccionario con bloques relevantes
    """
    # Limpiar texto fragmentado
    texto_limpiado = re.sub(r'\s+', ' ', texto_completo)
    texto_limpiado = re.sub(r'([A-Z])\s+([A-Z])', r'\1\2', texto_limpiado)
    texto_limpiado = re.sub(r'([0-9])\s+([0-9])', r'\1\2', texto_limpiado)
    
    bloques = {
        "cabecera": "",
        "energia": "",
        "otros_servicios": ""
    }
    
    # Buscar patrones espec√≠ficos en el texto completo
    cabecera_patrones = []
    energia_patrones = []
    otros_patrones = []
    
    # Patrones para cabecera
    cabecera_patrones.extend(re.findall(r'[A-Z√Å√â√ç√ì√ö√ë\s]{5,}', texto_limpiado))  # Nombres
    cabecera_patrones.extend(re.findall(r'CONTRATO\s+\d+', texto_limpiado))
    cabecera_patrones.extend(re.findall(r'TOTAL\s+A\s+PAGAR\s+\$?\s*[\d,]+\.?\d*', texto_limpiado))
    cabecera_patrones.extend(re.findall(r'PERIODO\s+FACTURACION\s+[A-Z\s]+', texto_limpiado))
    cabecera_patrones.extend(re.findall(r'D√çAS\s+FACTURADOS\s+\d+', texto_limpiado))
    
    # Patrones para energ√≠a
    energia_patrones.extend(re.findall(r'CONSUMO\s+DE\s+ENERG√çA\s+ACTIVA\s+[\d,]+\.?\d*\s*KWH', texto_limpiado))
    energia_patrones.extend(re.findall(r'VALOR\s+UNITARIO\s+[\d,]+\.?\d*', texto_limpiado))
    energia_patrones.extend(re.findall(r'SUBTOTAL\s+SERVICIOS\s+EMCALI\s+\$?\s*[\d,]+\.?\d*', texto_limpiado))
    energia_patrones.extend(re.findall(r'CONSUMO\s+ACTUAL\s+[\d,]+\.?\d*\s*KWH', texto_limpiado))
    
    # Patrones para otros servicios
    otros_patrones.extend(re.findall(r'ALUMBRADO\s+P√öBLICO\s+\(AP\)', texto_limpiado))
    otros_patrones.extend(re.findall(r'TASA\s+SEGURIDAD\s+\(TS\)', texto_limpiado))
    otros_patrones.extend(re.findall(r'SUBTOTAL\s+OTROS\s+SERVICIOS\s+\+\s+AP\s+\+\s+TS\s+\$?\s*[\d,]+\.?\d*', texto_limpiado))
    
    # Agregar l√≠neas que contengan estos patrones
    lineas = texto_completo.split('\n')
    
    for linea in lineas:
        linea_upper = linea.upper()
        
        # Cabecera
        if any(palabra in linea_upper for palabra in ['CLIENTE', 'CONTRATO', 'NIT', 'DIRECCION', 'PERIODO', 'TOTAL A PAGAR', 'FECHA', 'NESTOR', 'ZULUAGA']):
            cabecera_patrones.append(linea)
        
        # Energ√≠a
        if any(palabra in linea_upper for palabra in ['ENERGIA', 'CONCEPTOS', 'CONSUMO', 'KWH', 'VALOR UNITARIO', 'SUBTOTAL', '7,111']):
            energia_patrones.append(linea)
        
        # Otros servicios
        if any(palabra in linea_upper for palabra in ['ASEO', 'ALUMBRADO', 'TASA SEGURIDAD', 'OTROS SERVICIOS', 'CARGOS ADICIONALES']):
            otros_patrones.append(linea)
    
    bloques["cabecera"] = "\n".join(set(cabecera_patrones))  # Usar set para eliminar duplicados
    bloques["energia"] = "\n".join(set(energia_patrones))
    bloques["otros_servicios"] = "\n".join(set(otros_patrones))
    
    return bloques


def guardar_debug_prompt(bloques: Dict[str, str], prompt_completo: str):
    """
    Guarda el prompt enviado al LLM para debug.
    
    Args:
        bloques: Bloques extra√≠dos
        prompt_completo: Prompt completo enviado al LLM
    """
    debug_dir = Path("outputs") / "debug"
    debug_dir.mkdir(parents=True, exist_ok=True)
    
    with open(debug_dir / "prompt_llm.txt", "w", encoding="utf-8") as f:
        f.write("=== PROMPT ENVIADO AL LLM ===\n\n")
        f.write(prompt_completo)
        f.write("\n\n=== BLOQUES EXTRA√çDOS ===\n\n")
        for nombre, contenido in bloques.items():
            f.write(f"--- {nombre.upper()} ---\n")
            f.write(contenido)
            f.write("\n\n")


def guardar_debug_respuesta(respuesta_llm: Dict[str, Any]):
    """
    Guarda la respuesta del LLM para debug.
    
    Args:
        respuesta_llm: Respuesta JSON del LLM
    """
    debug_dir = Path("outputs") / "debug"
    debug_dir.mkdir(parents=True, exist_ok=True)
    
    with open(debug_dir / "respuesta_llm.json", "w", encoding="utf-8") as f:
        json.dump(respuesta_llm, f, ensure_ascii=False, indent=2)


def validar_esquema_json(respuesta: Dict[str, Any]) -> bool:
    """
    Valida que la respuesta cumpla el esquema JSON requerido.
    
    Args:
        respuesta: Respuesta del LLM
        
    Returns:
        True si cumple el esquema, False en caso contrario
    """
    try:
        # Validar estructura b√°sica
        campos_requeridos = ["cliente", "periodo", "energia", "otros_servicios", "total_pagar_cop", "justificaciones"]
        for campo in campos_requeridos:
            if campo not in respuesta:
                return False
        
        # Validar cliente
        cliente = respuesta.get("cliente", {})
        if not isinstance(cliente, dict):
            return False
        if not all(k in cliente for k in ["nombre", "direccion", "contrato"]):
            return False
        
        # Validar periodo
        periodo = respuesta.get("periodo", {})
        if not isinstance(periodo, dict):
            return False
        if not all(k in periodo for k in ["desde", "hasta", "dias"]):
            return False
        
        # Validar energia
        energia = respuesta.get("energia", {})
        if not isinstance(energia, dict):
            return False
        if not all(k in energia for k in ["activa_kwh", "valor_unitario_cop_kwh", "subtotal_energia_cop"]):
            return False
        
        # Validar otros_servicios
        otros = respuesta.get("otros_servicios", {})
        if not isinstance(otros, dict):
            return False
        if not all(k in otros for k in ["aseo_cop", "alumbrado_publico_cop", "tasa_seguridad_cop"]):
            return False
        
        # Validar justificaciones
        justificaciones = respuesta.get("justificaciones", [])
        if not isinstance(justificaciones, list):
            return False
        
        return True
        
    except Exception:
        return False


def extraer_datos_directos(texto_crudo: str) -> Dict[str, Any]:
    """
    Extrae datos directamente del texto usando regex, sin depender del LLM.
    
    Args:
        texto_crudo: Texto extra√≠do del PDF
        
    Returns:
        Datos extra√≠dos en formato JSON
    """
    datos = {
        "cliente": {"nombre": None, "direccion": None, "contrato": None},
        "periodo": {"desde": None, "hasta": None, "dias": 0},
        "energia": {"activa_kwh": None, "valor_unitario_cop_kwh": None, "subtotal_energia_cop": None},
        "otros_servicios": {"aseo_cop": None, "alumbrado_publico_cop": None, "tasa_seguridad_cop": None},
        "total_pagar_cop": None,
        "justificaciones": []
    }
    
    # Limpiar texto
    texto_limpiado = re.sub(r'\s+', ' ', texto_crudo)
    
    # Extraer cliente
    match = re.search(r'NESTOR\s+ZULUAGA\s+GOMEZ', texto_limpiado, re.IGNORECASE)
    if match:
        datos["cliente"]["nombre"] = "NESTOR ZULUAGA GOMEZ"
    
    # Extraer direcci√≥n
    match = re.search(r'CL\s+7\s+OESTE\s+AV\s+1-70\s+ZC', texto_limpiado, re.IGNORECASE)
    if match:
        datos["cliente"]["direccion"] = "CL 7 OESTE AV 1-70 ZC"
    
    # Extraer contrato
    match = re.search(r'CONTRATO\s+(\d+)', texto_limpiado, re.IGNORECASE)
    if match:
        datos["cliente"]["contrato"] = match.group(1)
    
    # Extraer per√≠odo
    match = re.search(r'MAR\s+26\s+a\s+ABR\s+24', texto_limpiado, re.IGNORECASE)
    if match:
        datos["periodo"]["desde"] = "MAR 26"
        datos["periodo"]["hasta"] = "ABR 24"
    
    # Extraer d√≠as
    match = re.search(r'D√çAS\s+FACTURADOS\s+(\d+)', texto_limpiado, re.IGNORECASE)
    if match:
        datos["periodo"]["dias"] = int(match.group(1))
    
    # Extraer consumo de energ√≠a
    match = re.search(r'(\d{1,3}(?:,\d{3})*\.?\d*)\s*KWH', texto_limpiado)
    if match:
        consumo_str = match.group(1).replace(',', '')
        try:
            datos["energia"]["activa_kwh"] = float(consumo_str)
        except:
            pass
    
    # Extraer valor unitario
    match = re.search(r'(\d{1,3}(?:\.\d{3})*,\d{2})', texto_limpiado)
    if match:
        valor_str = match.group(1).replace('.', '').replace(',', '.')
        try:
            valor = float(valor_str)
            # Verificar que sea un valor unitario plausible (entre 500 y 1200)
            if 500 <= valor <= 1200:
                datos["energia"]["valor_unitario_cop_kwh"] = valor
        except:
            pass
    
    # Buscar valor unitario espec√≠fico de 838.07
    match = re.search(r'838\.07', texto_limpiado)
    if match:
        datos["energia"]["valor_unitario_cop_kwh"] = 838.07
    
    # Extraer subtotal energ√≠a
    match = re.search(r'SUBTOTAL\s+SERVICIOS\s+EMCALI\s+\$?\s*(\d{1,3}(?:,\d{3})*\.?\d*)', texto_limpiado, re.IGNORECASE)
    if match:
        subtotal_str = match.group(1).replace(',', '')
        try:
            datos["energia"]["subtotal_energia_cop"] = float(subtotal_str)
        except:
            pass
    
    # Extraer total a pagar
    match = re.search(r'TOTAL\s+A\s+PAGAR\s+\$\s*(\d{1,3}(?:,\d{3})*\.?\d*)', texto_limpiado, re.IGNORECASE)
    if match:
        total_str = match.group(1).replace(',', '')
        try:
            datos["total_pagar_cop"] = float(total_str)
        except:
            pass
    
    # Extraer alumbrado p√∫blico
    match = re.search(r'ALUMBRADO\s+P√öBLICO.*?(\d{1,3}(?:,\d{3})*\.?\d*)', texto_limpiado, re.IGNORECASE | re.DOTALL)
    if match:
        alumbrado_str = match.group(1).replace(',', '')
        try:
            datos["otros_servicios"]["alumbrado_publico_cop"] = float(alumbrado_str)
        except:
            pass
    
    # Buscar alumbrado p√∫blico espec√≠fico
    match = re.search(r'ALUMB\.PUB\.NORESIDENCIALCALI\s+(\d{1,3}(?:,\d{3})*\.?\d*)', texto_limpiado, re.IGNORECASE)
    if match:
        alumbrado_str = match.group(1).replace(',', '')
        try:
            datos["otros_servicios"]["alumbrado_publico_cop"] = float(alumbrado_str)
        except:
            pass
    
    # Buscar alumbrado p√∫blico con formato espec√≠fico
    match = re.search(r'ALUMB\.PUB\.NORESIDENCIALCALI\s+(\d{1,3},\d{3}\.\d{2})', texto_limpiado, re.IGNORECASE)
    if match:
        alumbrado_str = match.group(1).replace(',', '')
        try:
            datos["otros_servicios"]["alumbrado_publico_cop"] = float(alumbrado_str)
        except:
            pass
    
    # Extraer tasa seguridad
    match = re.search(r'TASA\s+SEGURIDAD.*?(\d{1,3}(?:,\d{3})*\.?\d*)', texto_limpiado, re.IGNORECASE | re.DOTALL)
    if match:
        tasa_str = match.group(1).replace(',', '')
        try:
            datos["otros_servicios"]["tasa_seguridad_cop"] = float(tasa_str)
        except:
            pass
    
    # Generar justificaciones para datos faltantes
    if not datos["cliente"]["nombre"]:
        datos["justificaciones"].append("No se encontr√≥ el nombre del cliente")
    if not datos["cliente"]["direccion"]:
        datos["justificaciones"].append("No se encontr√≥ la direcci√≥n del cliente")
    if not datos["cliente"]["contrato"]:
        datos["justificaciones"].append("No se encontr√≥ el n√∫mero de contrato")
    if not datos["periodo"]["desde"]:
        datos["justificaciones"].append("No se encontr√≥ la fecha de inicio del per√≠odo")
    if not datos["periodo"]["hasta"]:
        datos["justificaciones"].append("No se encontr√≥ la fecha de fin del per√≠odo")
    if not datos["energia"]["activa_kwh"]:
        datos["justificaciones"].append("No se encontr√≥ el consumo de energ√≠a activa")
    if not datos["energia"]["valor_unitario_cop_kwh"]:
        datos["justificaciones"].append("No se encontr√≥ el valor unitario por kWh")
    if not datos["energia"]["subtotal_energia_cop"]:
        datos["justificaciones"].append("No se encontr√≥ el subtotal de energ√≠a")
    if not datos["total_pagar_cop"]:
        datos["justificaciones"].append("No se encontr√≥ el total a pagar")
    
    return datos


def analizar_factura_llm(texto_crudo_pdf: str, datos_extraidos: Dict[str, Any], historico: Optional[List[Dict[str, Any]]] = None) -> Dict[str, Any]:
    """
    Analiza factura con LLM usando el nuevo prompt EMCALI v1 y esquema JSON.
    
    Args:
        texto_crudo_pdf: Texto extra√≠do del PDF
        datos_extraidos: Datos ya extra√≠dos (no se usan en este enfoque)
        historico: Hist√≥rico de consumo (no se usa en este enfoque)
        
    Returns:
        Diccionario con payload (canonica + raw_line_items) y raw_text
    """
    try:
        # Cargar prompt y esquema
        prompt = cargar_prompt_emcali()
        schema = cargar_schema_emcali()
        
        # Preparar prompt completo
        prompt_completo = f"{prompt}\n\nTEXTO COMPLETO DE LA FACTURA:\n{texto_crudo_pdf}"
        
        # Llamar al modelo con temperatura 0.1
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "user", "content": prompt_completo}
            ],
            temperature=0.1,
            max_tokens=3000
        )
        
        # Extraer respuesta JSON
        respuesta_texto = response.choices[0].message.content.strip()
        
        # Extraer bloque JSON de forma robusta
        json_data = extraer_json_robusto(respuesta_texto)
        
        if not json_data:
            return {
                "error": "No se pudo extraer JSON v√°lido de la respuesta del LLM",
                "respuesta_raw": respuesta_texto,
                "raw_text": texto_crudo_pdf
            }
        
        # Normalizar campos num√©ricos y fechas
        payload = normalizar_datos_emcali(json_data)
        
        # A√±adir metadatos de versi√≥n
        if "canonica" in payload and "metadatos" in payload["canonica"]:
            payload["canonica"]["metadatos"]["prompt_version"] = "emcali_v1"
            payload["canonica"]["metadatos"]["schema_version"] = "emcali_v1"
        
        # Guardar para debug
        guardar_debug_analisis_emcali(texto_crudo_pdf, respuesta_texto, payload)
        
        return {
            "payload": payload,
            "raw_text": texto_crudo_pdf
        }
        
    except Exception as e:
        return {
            "error": f"Error en an√°lisis LLM: {str(e)}",
            "respuesta_raw": "",
            "raw_text": texto_crudo_pdf
        }


def extraer_json_robusto(respuesta_texto: str) -> Optional[Dict[str, Any]]:
    """
    Extrae JSON de la respuesta del LLM de forma robusta.
    """
    try:
        # Limpiar respuesta si tiene markdown
        if respuesta_texto.startswith("```json"):
            respuesta_texto = respuesta_texto[7:]
        if respuesta_texto.endswith("```"):
            respuesta_texto = respuesta_texto[:-3]
        
        respuesta_texto = respuesta_texto.strip()
        
        # Intentar parsear directamente
        return json.loads(respuesta_texto)
        
    except json.JSONDecodeError:
        # Buscar JSON dentro del texto
        try:
            # Buscar patrones de JSON
            json_patterns = [
                r'\{.*\}',  # JSON simple
                r'\{.*\}(?:\s*\{.*\})*',  # JSON anidado
            ]
            
            for pattern in json_patterns:
                matches = re.findall(pattern, respuesta_texto, re.DOTALL)
                for match in matches:
                    try:
                        return json.loads(match)
                    except json.JSONDecodeError:
                        continue
            
            return None
            
        except Exception:
            return None


def normalizar_datos_emcali(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Normaliza los datos extra√≠dos usando las funciones de utils.
    """
    if not isinstance(data, dict):
        return data
    
    # Normalizar canonica
    if "canonica" in data and isinstance(data["canonica"], dict):
        canonica = data["canonica"]
        
        # Normalizar fechas
        if "periodo_inicio" in canonica:
            canonica["periodo_inicio"] = utils.parse_iso_date(canonica["periodo_inicio"])
        if "periodo_fin" in canonica:
            canonica["periodo_fin"] = utils.parse_iso_date(canonica["periodo_fin"])
        
        # Normalizar n√∫meros
        if "dias_facturados" in canonica:
            canonica["dias_facturados"] = utils.to_float_us(canonica["dias_facturados"])
        if "iva_total_cop" in canonica:
            canonica["iva_total_cop"] = utils.clean_cop(canonica["iva_total_cop"])
        if "total_pagar_cop" in canonica:
            canonica["total_pagar_cop"] = utils.clean_cop(canonica["total_pagar_cop"])
        
        # Normalizar energ√≠a
        if "energia" in canonica and isinstance(canonica["energia"], dict):
            energia = canonica["energia"]
            for key in ["lectura_inicial", "lectura_final", "consumo_kwh", "cuv_cop_kwh", "base_cop", "total_cop"]:
                if key in energia:
                    energia[key] = utils.to_float_us(energia[key])
        
        # Normalizar acueducto
        if "acueducto" in canonica and isinstance(canonica["acueducto"], dict):
            acueducto = canonica["acueducto"]
            for key in ["consumo_m3", "tarifa_cop_m3", "total_cop"]:
                if key in acueducto:
                    acueducto[key] = utils.to_float_us(acueducto[key])
        
        # Normalizar alcantarillado
        if "alcantarillado" in canonica and isinstance(canonica["alcantarillado"], dict):
            alcantarillado = canonica["alcantarillado"]
            for key in ["consumo_m3", "tarifa_cop_m3", "total_cop"]:
                if key in alcantarillado:
                    alcantarillado[key] = utils.to_float_us(alcantarillado[key])
        
        # Normalizar otros servicios
        for servicio in ["aseo", "alumbrado_publico", "tasa_seguridad"]:
            if servicio in canonica and isinstance(canonica[servicio], dict):
                if "total_cop" in canonica[servicio]:
                    canonica[servicio]["total_cop"] = utils.clean_cop(canonica[servicio]["total_cop"])
        
        # Normalizar otros items
        if "otros" in canonica and isinstance(canonica["otros"], dict):
            otros = canonica["otros"]
            if "total_cop" in otros:
                otros["total_cop"] = utils.clean_cop(otros["total_cop"])
            if "items" in otros and isinstance(otros["items"], list):
                for item in otros["items"]:
                    if isinstance(item, dict) and "total_cop" in item:
                        item["total_cop"] = utils.clean_cop(item["total_cop"])
    
    return data


def guardar_debug_analisis_emcali(texto_pdf: str, respuesta_llm: str, payload: Dict[str, Any]):
    """
    Guarda informaci√≥n de debug para el an√°lisis EMCALI v1.
    """
    debug_dir = Path("outputs") / "debug"
    debug_dir.mkdir(parents=True, exist_ok=True)
    
    # Guardar prompt y respuesta
    with open(debug_dir / "prompt_llm.txt", "w", encoding="utf-8") as f:
        f.write("=== PROMPT EMCALI V1 ENVIADO AL LLM ===\n\n")
        f.write(cargar_prompt_emcali())
        f.write("\n\n=== TEXTO DEL PDF ===\n\n")
        f.write(texto_pdf)
    
    # Guardar respuesta del LLM
    with open(debug_dir / "respuesta_llm.json", "w", encoding="utf-8") as f:
        json.dump({
            "respuesta_raw": respuesta_llm,
            "payload": payload,
            "timestamp": str(Path().cwd())
        }, f, ensure_ascii=False, indent=2)


def formatear_analisis(analisis_json: Dict[str, Any]) -> str:
    """
    Formatea el an√°lisis JSON para el informe.
    
    Args:
        analisis_json: An√°lisis estructurado del LLM
        
    Returns:
        Texto formateado para el informe
    """
    if not analisis_json or "error" in analisis_json:
        return f"No se pudo generar an√°lisis: {analisis_json.get('error', 'Error desconocido')}"
    
    # Construir texto formateado
    texto = []
    
    # Informaci√≥n del cliente
    cliente = analisis_json.get("cliente", {})
    texto.append("## INFORMACI√ìN DEL CLIENTE")
    texto.append(f"**Nombre:** {cliente.get('nombre', 'No extra√≠do')}")
    texto.append(f"**Direcci√≥n:** {cliente.get('direccion', 'No extra√≠da')}")
    texto.append(f"**Contrato:** {cliente.get('contrato', 'No extra√≠do')}")
    texto.append("")
    
    # Per√≠odo
    periodo = analisis_json.get("periodo", {})
    texto.append("## PER√çODO DE FACTURACI√ìN")
    texto.append(f"**Desde:** {periodo.get('desde', 'No extra√≠do')}")
    texto.append(f"**Hasta:** {periodo.get('hasta', 'No extra√≠do')}")
    texto.append(f"**D√≠as:** {periodo.get('dias', 'No extra√≠do')}")
    texto.append("")
    
    # Energ√≠a
    energia = analisis_json.get("energia", {})
    texto.append("## CONSUMO DE ENERG√çA")
    texto.append(f"**Energ√≠a Activa:** {energia.get('activa_kwh', 'No extra√≠do')} kWh")
    texto.append(f"**Valor Unitario:** ${energia.get('valor_unitario_cop_kwh', 'No extra√≠do'):,.2f} COP/kWh" if energia.get('valor_unitario_cop_kwh') else "**Valor Unitario:** No extra√≠do")
    texto.append(f"**Subtotal Energ√≠a:** ${energia.get('subtotal_energia_cop', 'No extra√≠do'):,.2f} COP" if energia.get('subtotal_energia_cop') else "**Subtotal Energ√≠a:** No extra√≠do")
    texto.append("")
    
    # Otros servicios
    otros = analisis_json.get("otros_servicios", {})
    texto.append("## OTROS SERVICIOS")
    texto.append(f"**Aseo:** ${otros.get('aseo_cop', 'No extra√≠do'):,.2f} COP" if otros.get('aseo_cop') else "**Aseo:** No extra√≠do")
    texto.append(f"**Alumbrado P√∫blico:** ${otros.get('alumbrado_publico_cop', 'No extra√≠do'):,.2f} COP" if otros.get('alumbrado_publico_cop') else "**Alumbrado P√∫blico:** No extra√≠do")
    texto.append(f"**Tasa Seguridad:** ${otros.get('tasa_seguridad_cop', 'No extra√≠do'):,.2f} COP" if otros.get('tasa_seguridad_cop') else "**Tasa Seguridad:** No extra√≠do")
    texto.append("")
    
    # Total
    total = analisis_json.get("total_pagar_cop", 0)
    texto.append("## TOTAL A PAGAR")
    texto.append(f"**Total:** ${total:,.2f} COP" if total else "**Total:** No extra√≠do")
    texto.append("")
    
    # Justificaciones
    justificaciones = analisis_json.get("justificaciones", [])
    if justificaciones:
        texto.append("## JUSTIFICACIONES")
        for i, just in enumerate(justificaciones, 1):
            texto.append(f"{i}. {just}")
        texto.append("")
    
    return "\n".join(texto)


def generar_csv_emcali(datos_extraidos: Dict[str, Any], ruta_salida: str = "outputs/facturas_emcali.csv"):
    """
    Genera un archivo CSV con los datos extra√≠dos de facturas EMCALI.
    
    Args:
        datos_extraidos: Datos extra√≠dos por el LLM
        ruta_salida: Ruta donde guardar el CSV
    """
    # Definir columnas del CSV seg√∫n el esquema EMCALI v1
    columnas = [
        "cliente_nombre", "contrato", "niu", "direccion_instalacion", "operador_red", 
        "nivel_tension", "medidor", "ciclo", "periodo_desde", "periodo_hasta", 
        "dias_facturados", "fecha_expedicion", "fecha_vencimiento", "lectura_anterior", 
        "lectura_actual", "diferencia_kwh", "consumo_kwh", "energia_kwh", 
        "energia_unitario_cop_kwh", "energia_valor_total", "energia_total_bloque", 
        "aseo_total", "alumbrado_publico_total", "tasa_seguridad_total", 
        "otros_cargos", "subtotal_emcali", "iva", "total_operacion_mes", 
        "total_a_pagar", "moneda"
    ]
    
    # Crear directorio si no existe
    Path(ruta_salida).parent.mkdir(parents=True, exist_ok=True)
    
    # Verificar si el archivo existe para decidir si escribir headers
    archivo_existe = Path(ruta_salida).exists()
    
    with open(ruta_salida, 'a', newline='', encoding='utf-8') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=columnas)
        
        # Escribir headers solo si el archivo no existe
        if not archivo_existe:
            writer.writeheader()
        
        # Preparar fila de datos
        fila = {}
        for columna in columnas:
            if columna == "otros_cargos":
                # Convertir lista de otros cargos a string
                otros = datos_extraidos.get(columna, [])
                if otros:
                    fila[columna] = "; ".join([f"{item.get('nombre', '')}: {item.get('total', '')}" for item in otros])
                else:
                    fila[columna] = ""
            else:
                fila[columna] = datos_extraidos.get(columna, "")
        
        # Escribir fila
        writer.writerow(fila)
    
    print(f"‚úÖ Datos guardados en CSV: {ruta_salida}")


def procesar_factura_emcali_completa(ruta_pdf: str, guardar_csv: bool = True) -> Dict[str, Any]:
    """
    Procesa una factura EMCALI completa: extrae texto, usa LLM, valida y opcionalmente guarda CSV.
    
    Args:
        ruta_pdf: Ruta al archivo PDF
        guardar_csv: Si guardar los datos en CSV
        
    Returns:
        Diccionario con resultados del procesamiento
    """
    try:
        # Importar funci√≥n de extracci√≥n de texto
        from extractor_simple import leer_pdf
        
        print(f"üîç Procesando factura EMCALI: {ruta_pdf}")
        
        # Paso 1: Extraer texto del PDF
        print("üìÑ Extrayendo texto del PDF...")
        texto_pdf = leer_pdf(ruta_pdf)
        
        if len(texto_pdf.strip()) < 100:
            return {"error": "Texto extra√≠do muy corto, posible PDF corrupto o sin texto"}
        
        # Paso 2: Extraer datos con LLM usando prompt espec√≠fico
        print("ü§ñ Extrayendo datos con LLM (prompt EMCALI v1)...")
        datos_extraidos = extraer_datos_emcali_llm(texto_pdf)
        
        if "error" in datos_extraidos:
            return datos_extraidos
        
        # Paso 3: Validar extracci√≥n
        print("‚úÖ Validando extracci√≥n...")
        es_valido, errores = validar_extraccion_emcali(datos_extraidos)
        
        # Paso 4: Guardar CSV si se solicita
        if guardar_csv and es_valido:
            print("üíæ Guardando en CSV...")
            generar_csv_emcali(datos_extraidos)
        
        # Retornar resultados
        return {
            "exito": True,
            "datos_extraidos": datos_extraidos,
            "es_valido": es_valido,
            "errores_validacion": errores,
            "campos_extraidos": len([k for k, v in datos_extraidos.items() if v is not None and k != "source_map"]),
            "total_campos": 29,  # Campos definidos en el esquema
            "porcentaje_completitud": round(len([k for k, v in datos_extraidos.items() if v is not None and k != "source_map"]) / 29 * 100, 1)
        }
        
    except Exception as e:
        return {"error": f"Error en procesamiento completo: {str(e)}"}





def validar_extraccion_emcali(datos: Dict[str, Any]) -> Tuple[bool, List[str]]:
    """
    Valida que la extracci√≥n EMCALI sea correcta seg√∫n los criterios definidos.
    
    Args:
        datos: Datos extra√≠dos por el LLM
        
    Returns:
        Tupla con (es_valido, lista_errores)
    """
    errores = []
    
    # Verificar campos obligatorios
    campos_obligatorios = [
        "cliente_nombre", "contrato", "niu", "direccion_instalacion",
        "periodo_desde", "periodo_hasta", "total_a_pagar"
    ]
    
    for campo in campos_obligatorios:
        if campo not in datos or datos[campo] is None:
            errores.append(f"Campo obligatorio '{campo}' no encontrado o es null")
    
    # Verificar formato de fechas
    if datos.get("periodo_desde") and not re.match(r'\d{4}-\d{2}-\d{2}', str(datos["periodo_desde"])):
        errores.append("periodo_desde no est√° en formato YYYY-MM-DD")
    
    if datos.get("periodo_hasta") and not re.match(r'\d{4}-\d{2}-\d{2}', str(datos["periodo_hasta"])):
        errores.append("periodo_hasta no est√° en formato YYYY-MM-DD")
    
    # Verificar que total_a_pagar sea el correcto
    if datos.get("total_a_pagar"):
        # Verificar que sea un n√∫mero v√°lido
        try:
            float(str(datos["total_a_pagar"]).replace(',', ''))
        except:
            errores.append("total_a_pagar no es un n√∫mero v√°lido")
    
    # Verificar source_map (opcional)
    if "source_map" in datos and not isinstance(datos["source_map"], dict):
        errores.append("source_map debe ser un diccionario si est√° presente")
    
    # Verificar moneda
    if datos.get("moneda") != "COP":
        errores.append("moneda debe ser 'COP'")
    
    return len(errores) == 0, errores
