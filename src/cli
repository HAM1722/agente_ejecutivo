#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CLI para el pipeline de procesamiento de facturas EMCALI
Incluye flags para procesamiento OCR y tests de regresiÃ³n
"""

import argparse
import sys
import json
import csv
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime

# Agregar el directorio src al path
sys.path.insert(0, str(Path(__file__).parent))

from procesar_factura_ocr import procesar_lote_facturas, procesar_factura_ocr, listar_facturas, obtener_facturas_procesadas
from utils import file_sha256


def procesar_una_factura(archivo_pdf: str) -> Dict[str, Any]:
    """
    Procesa una factura especÃ­fica.
    
    Args:
        archivo_pdf: Ruta al archivo PDF
        
    Returns:
        Resultado del procesamiento
    """
    pdf_path = Path(archivo_pdf)
    if not pdf_path.exists():
        return {"error": f"Archivo no encontrado: {archivo_pdf}"}
    
    print(f"ğŸ”„ Procesando factura especÃ­fica: {pdf_path.name}")
    return procesar_factura_ocr(pdf_path)


def reprocesar_todas() -> Dict[str, Any]:
    """
    Reprocesa todas las facturas existentes.
    
    Returns:
        Resumen del reprocesamiento
    """
    print("ğŸ”„ Reprocesando todas las facturas...")
    
    facturas = listar_facturas()
    if not facturas:
        return {"error": "No se encontraron archivos PDF en data/"}
    
    resultados = []
    for i, factura in enumerate(facturas, 1):
        print(f"ğŸ”„ {i}/{len(facturas)} Reprocesando {factura.name}")
        resultado = procesar_factura_ocr(factura)
        resultados.append(resultado)
    
    # Resumen
    exitosos = sum(1 for r in resultados if r.get("success", False))
    fallidos = len(resultados) - exitosos
    
    return {
        "total_facturas": len(facturas),
        "exitosos": exitosos,
        "fallidos": fallidos,
        "resultados": resultados
    }


def generar_reporte() -> Dict[str, Any]:
    """
    Genera reporte de mÃ©tricas y calidad.
    
    Returns:
        Diccionario con mÃ©tricas del reporte
    """
    csv_path = Path("outputs/facturas_emcali.csv")
    if not csv_path.exists():
        return {"error": "No se encontrÃ³ el CSV de facturas procesadas"}
    
    # Leer CSV
    facturas = []
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            facturas.append(row)
    
    if not facturas:
        return {"error": "CSV vacÃ­o"}
    
    # Calcular mÃ©tricas
    total_facturas = len(facturas)
    
    # Confidence scores
    confidence_scores = []
    for factura in facturas:
        try:
            score = float(factura.get('confidence_score', 0))
            confidence_scores.append(score)
        except (ValueError, TypeError):
            confidence_scores.append(0.0)
    
    avg_confidence = sum(confidence_scores) / len(confidence_scores) if confidence_scores else 0.0
    high_confidence = sum(1 for score in confidence_scores if score >= 0.9)
    low_confidence = sum(1 for score in confidence_scores if score < 0.7)
    
    # Flags de calidad
    total_flags = 0
    flag_counts = {}
    for factura in facturas:
        flags = factura.get('flags_join', '').split(';') if factura.get('flags_join') else []
        total_flags += len(flags)
        for flag in flags:
            if flag:
                flag_counts[flag] = flag_counts.get(flag, 0) + 1
    
    # Totales monetarios
    total_pagar_sum = 0.0
    for factura in facturas:
        try:
            total = float(factura.get('total_pagar_cop', 0))
            total_pagar_sum += total
        except (ValueError, TypeError):
            pass
    
    return {
        "total_facturas": total_facturas,
        "confidence_metrics": {
            "promedio": round(avg_confidence, 3),
            "alta_confianza": high_confidence,
            "baja_confianza": low_confidence,
            "porcentaje_alta": round((high_confidence / total_facturas) * 100, 1) if total_facturas > 0 else 0
        },
        "quality_flags": {
            "total_flags": total_flags,
            "promedio_por_factura": round(total_flags / total_facturas, 2) if total_facturas > 0 else 0,
            "flag_counts": flag_counts
        },
        "monetary": {
            "total_facturado": round(total_pagar_sum, 2)
        },
        "periodo": {
            "primera_factura": min((f.get('processed_at', '') for f in facturas), default=''),
            "ultima_factura": max((f.get('processed_at', '') for f in facturas), default='')
        }
    }


def ejecutar_tests_golden() -> Dict[str, Any]:
    """
    Ejecuta tests de regresiÃ³n contra golden set.
    
    Returns:
        Resultados de los tests
    """
    golden_dir = Path("tests/golden")
    if not golden_dir.exists():
        return {"error": "No se encontrÃ³ el directorio tests/golden"}
    
    # Buscar archivos golden
    golden_files = list(golden_dir.glob("*.pdf"))
    if not golden_files:
        return {"error": "No se encontraron archivos PDF en tests/golden"}
    
    resultados = []
    exitosos = 0
    fallidos = 0
    
    for pdf_file in golden_files:
        print(f"ğŸ§ª Probando golden: {pdf_file.name}")
        
        # Calcular hash
        pdf_hash = file_sha256(str(pdf_file))
        
        # Buscar JSON esperado
        json_esperado_path = golden_dir / f"{pdf_hash}.json"
        if not json_esperado_path.exists():
            print(f"âš ï¸ No se encontrÃ³ JSON esperado para {pdf_file.name}")
            fallidos += 1
            continue
        
        # Procesar factura
        resultado = procesar_factura_pipeline(pdf_file)
        if not resultado.get("success", False):
            print(f"âŒ Error procesando {pdf_file.name}")
            fallidos += 1
            continue
        
        # Comparar con golden
        json_resultado_path = Path("outputs/json") / f"{pdf_hash}.json"
        if not json_resultado_path.exists():
            print(f"âŒ No se generÃ³ JSON para {pdf_file.name}")
            fallidos += 1
            continue
        
        # Cargar archivos para comparaciÃ³n
        try:
            with open(json_esperado_path, 'r', encoding='utf-8') as f:
                golden_data = json.load(f)
            
            with open(json_resultado_path, 'r', encoding='utf-8') as f:
                resultado_data = json.load(f)
            
            # Comparar campos crÃ­ticos
            diferencias = comparar_datos(golden_data, resultado_data)
            
            if diferencias:
                print(f"âŒ Diferencias encontradas en {pdf_file.name}: {diferencias}")
                fallidos += 1
            else:
                print(f"âœ… Test pasado para {pdf_file.name}")
                exitosos += 1
            
            resultados.append({
                "archivo": pdf_file.name,
                "exitoso": not diferencias,
                "diferencias": diferencias
            })
            
        except Exception as e:
            print(f"âŒ Error comparando {pdf_file.name}: {e}")
            fallidos += 1
    
    return {
        "total_tests": len(golden_files),
        "exitosos": exitosos,
        "fallidos": fallidos,
        "porcentaje_exito": round((exitosos / len(golden_files)) * 100, 1) if golden_files else 0,
        "resultados": resultados
    }


def comparar_datos(golden: Dict[str, Any], resultado: Dict[str, Any]) -> List[str]:
    """
    Compara datos golden con resultado actual.
    
    Args:
        golden: Datos golden esperados
        resultado: Datos actuales
        
    Returns:
        Lista de diferencias encontradas
    """
    diferencias = []
    
    # Campos crÃ­ticos a comparar
    campos_criticos = [
        'total_pagar_cop',
        'energia_total_cop',
        'acueducto_total_cop',
        'alcantarillado_total_cop',
        'aseo_total_cop',
        'ap_total_cop',
        'ts_total_cop',
        'iva_total_cop'
    ]
    
    golden_canonica = golden.get('canonica', {})
    resultado_canonica = resultado.get('canonica', {})
    
    for campo in campos_criticos:
        golden_valor = golden_canonica.get(campo, 0)
        resultado_valor = resultado_canonica.get(campo, 0)
        
        # Comparar con tolerancia
        if isinstance(golden_valor, (int, float)) and isinstance(resultado_valor, (int, float)):
            diferencia = abs(golden_valor - resultado_valor)
            if diferencia > 1.0:  # Tolerancia de 1 COP
                diferencias.append(f"{campo}: golden={golden_valor}, actual={resultado_valor}")
    
    return diferencias


def imprimir_reporte(reporte: Dict[str, Any]):
    """Imprime el reporte de mÃ©tricas de forma legible."""
    if "error" in reporte:
        print(f"âŒ Error: {reporte['error']}")
        return
    
    print("\n" + "=" * 60)
    print("ğŸ“Š REPORTE DE MÃ‰TRICAS - PIPELINE EMCALI")
    print("=" * 60)
    
    print(f"ğŸ“‹ Total de facturas procesadas: {reporte['total_facturas']}")
    
    # MÃ©tricas de confianza
    conf = reporte['confidence_metrics']
    print(f"\nğŸ¯ MÃ‰TRICAS DE CONFIANZA:")
    print(f"   Promedio: {conf['promedio']:.1%}")
    print(f"   Alta confianza (â‰¥90%): {conf['alta_confianza']} ({conf['porcentaje_alta']}%)")
    print(f"   Baja confianza (<70%): {conf['baja_confianza']}")
    
    # Flags de calidad
    flags = reporte['quality_flags']
    print(f"\nğŸ·ï¸ FLAGS DE CALIDAD:")
    print(f"   Total de flags: {flags['total_flags']}")
    print(f"   Promedio por factura: {flags['promedio_por_factura']}")
    
    if flags['flag_counts']:
        print("   Flags mÃ¡s comunes:")
        for flag, count in sorted(flags['flag_counts'].items(), key=lambda x: x[1], reverse=True)[:5]:
            print(f"     â€¢ {flag}: {count}")
    
    # MÃ©tricas monetarias
    monetary = reporte['monetary']
    print(f"\nğŸ’° MÃ‰TRICAS MONETARIAS:")
    print(f"   Total facturado: ${monetary['total_facturado']:,.2f} COP")
    
    # PerÃ­odo
    periodo = reporte['periodo']
    if periodo['primera_factura'] and periodo['ultima_factura']:
        print(f"\nğŸ“… PERÃODO:")
        print(f"   Primera factura: {periodo['primera_factura'][:10]}")
        print(f"   Ãšltima factura: {periodo['ultima_factura'][:10]}")


def imprimir_tests_resultado(resultado: Dict[str, Any]):
    """Imprime el resultado de los tests de regresiÃ³n."""
    if "error" in resultado:
        print(f"âŒ Error: {resultado['error']}")
        return
    
    print("\n" + "=" * 60)
    print("ğŸ§ª RESULTADOS DE TESTS DE REGRESIÃ“N")
    print("=" * 60)
    
    print(f"ğŸ“‹ Total de tests: {resultado['total_tests']}")
    print(f"âœ… Exitosos: {resultado['exitosos']}")
    print(f"âŒ Fallidos: {resultado['fallidos']}")
    print(f"ğŸ“Š Porcentaje de Ã©xito: {resultado['porcentaje_exito']}%")
    
    if resultado['resultados']:
        print(f"\nğŸ“ DETALLE DE RESULTADOS:")
        for test in resultado['resultados']:
            status = "âœ…" if test['exitoso'] else "âŒ"
            print(f"   {status} {test['archivo']}")
            if test['diferencias']:
                for diff in test['diferencias']:
                    print(f"      âš ï¸ {diff}")


def main():
    """FunciÃ³n principal del CLI."""
    print("ğŸ” CLI iniciado...")
    parser = argparse.ArgumentParser(
        description="CLI para procesamiento de facturas EMCALI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Ejemplos de uso:
  python -m src.cli --extract-only                    # Solo extracciÃ³n OCR (sin LLM/DOCX)
  python -m src.cli --extract-only --force-ocr        # Forzar OCR
  python -m src.cli --extract-only --strict           # Modo estricto
  python -m src.cli --extract-only --input-dir data --output-dir outputs  # Directorios personalizados
  python -m src.cli --reprocess                       # Reprocesar todas las facturas (modo LLM)
  python -m src.cli --report                          # Generar reporte de mÃ©tricas
  python -m src.cli --one factura.pdf                 # Procesar una factura especÃ­fica
  python -m src.cli --test                            # Ejecutar tests de regresiÃ³n
        """
    )
    
    # Flags para extracciÃ³n OCR
    parser.add_argument(
        '--extract-only',
        action='store_true',
        help='Solo extracciÃ³n OCR (sin LLM, sin DOCX)'
    )
    
    parser.add_argument(
        '--force-ocr',
        action='store_true',
        help='Forzar OCR aunque haya texto embebido'
    )
    
    parser.add_argument(
        '--strict',
        action='store_true',
        help='Falla si no pasa conciliaciÃ³n o completitud'
    )
    
    parser.add_argument(
        '--input-dir',
        type=str,
        default='data',
        help='Directorio de entrada con PDFs (default: data)'
    )
    
    parser.add_argument(
        '--output-dir',
        type=str,
        default='outputs',
        help='Directorio de salida (default: outputs)'
    )
    
    # Flags legacy para modo LLM
    parser.add_argument(
        '--reprocess',
        action='store_true',
        help='Reprocesar todas las facturas (modo LLM)'
    )
    
    parser.add_argument(
        '--report',
        action='store_true',
        help='Generar reporte de mÃ©tricas y calidad'
    )
    
    parser.add_argument(
        '--one',
        type=str,
        help='Procesar una factura especÃ­fica (ruta al PDF)'
    )
    
    parser.add_argument(
        '--test',
        action='store_true',
        help='Ejecutar tests de regresiÃ³n contra golden set'
    )
    
    args = parser.parse_args()
    
    try:
        if args.extract_only:
            print("ğŸ” Iniciando extracciÃ³n OCR...")
            resultado = procesar_lote_facturas(
                directorio_entrada=args.input_dir,
                directorio_salida=args.output_dir,
                force_ocr=args.force_ocr,
                strict=args.strict
            )
            
            if "error" in resultado:
                print(f"âŒ Error: {resultado['error']}")
                sys.exit(1)
            else:
                print(f"âœ… ExtracciÃ³n completada: {resultado['exitosos']} exitosos, {resultado['fallidos']} fallidos")
                
        elif args.report:
            print("ğŸ“Š Generando reporte de mÃ©tricas...")
            reporte = generar_reporte()
            imprimir_reporte(reporte)
            
        elif args.test:
            print("ğŸ§ª Ejecutando tests de regresiÃ³n...")
            resultado = ejecutar_tests_golden()
            imprimir_tests_resultado(resultado)
            
        elif args.one:
            if not args.one:
                print("âŒ Error: Debe especificar la ruta al archivo PDF")
                sys.exit(1)
            
            # Determinar si usar OCR o LLM basado en la extensiÃ³n o contenido
            if args.one.endswith('.pdf'):
                resultado = procesar_factura_ocr(Path(args.one), args.force_ocr, args.strict)
            else:
                resultado = procesar_una_factura(args.one)
                
            if "error" in resultado or not resultado.get("success", False):
                print(f"âŒ Error: {resultado.get('error', resultado.get('errors', 'Error desconocido'))}")
                sys.exit(1)
            else:
                print("âœ… Factura procesada exitosamente")
                
        elif args.reprocess:
            resultado = reprocesar_todas()
            if "error" in resultado:
                print(f"âŒ Error: {resultado['error']}")
                sys.exit(1)
            else:
                print(f"âœ… Reprocesamiento completado: {resultado['exitosos']} exitosos, {resultado['fallidos']} fallidos")
                
        else:
            # Modo por defecto: extracciÃ³n OCR
            print("ğŸ” Iniciando extracciÃ³n OCR (modo por defecto)...")
            resultado = procesar_lote_facturas(
                directorio_entrada=args.input_dir,
                directorio_salida=args.output_dir,
                force_ocr=args.force_ocr,
                strict=args.strict
            )
            
            if "error" in resultado:
                print(f"âŒ Error: {resultado['error']}")
                sys.exit(1)
            else:
                print(f"âœ… ExtracciÃ³n completada: {resultado['exitosos']} exitosos, {resultado['fallidos']} fallidos")
            
    except KeyboardInterrupt:
        print("\nâ¹ï¸ OperaciÃ³n interrumpida por el usuario")
        sys.exit(1)
    except Exception as e:
        print(f"\nâŒ Error inesperado: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
