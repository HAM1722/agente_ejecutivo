#!/usr/bin/env python3
"""
Utilidades genéricas para normalización de datos y operaciones de IO.
"""

import re
import hashlib
import os
from typing import Union, Optional
from datetime import datetime


def to_float_us(x: Union[str, float, int, None]) -> Optional[float]:
    """
    Convierte un valor a float en formato US (1234.56).
    Maneja strings con comas como separadores de miles.
    """
    if x is None:
        return None
    
    if isinstance(x, (int, float)):
        return float(x)
    
    if isinstance(x, str):
        # Limpiar espacios y caracteres no numéricos excepto . y ,
        cleaned = re.sub(r'[^\d.,-]', '', x.strip())
        
        # Manejar formato con comas (ej: 1,234.56)
        if ',' in cleaned and '.' in cleaned:
            # Si hay coma antes del punto, es separador de miles
            comma_pos = cleaned.find(',')
            dot_pos = cleaned.find('.')
            if comma_pos < dot_pos:
                cleaned = cleaned.replace(',', '')
        
        # Manejar formato europeo (ej: 1234,56)
        elif ',' in cleaned and '.' not in cleaned:
            cleaned = cleaned.replace(',', '.')
        
        try:
            return float(cleaned)
        except ValueError:
            return None
    
    return None


def clean_cop(x: Union[str, float, int, None]) -> Optional[float]:
    """
    Limpia valores monetarios en COP, removiendo símbolos de moneda.
    """
    if x is None:
        return None
    
    if isinstance(x, (int, float)):
        return float(x)
    
    if isinstance(x, str):
        # Remover símbolos de moneda y espacios
        cleaned = re.sub(r'[^\d.,-]', '', x.strip())
        return to_float_us(cleaned)
    
    return None


def percent_to_ratio(x: Union[str, float, None]) -> Optional[float]:
    """
    Convierte porcentaje a ratio (ej: "15%" -> 0.15).
    """
    if x is None:
        return None
    
    if isinstance(x, float):
        return x / 100.0
    
    if isinstance(x, str):
        # Remover símbolo % y espacios
        cleaned = re.sub(r'[^\d.,-]', '', x.strip())
        value = to_float_us(cleaned)
        if value is not None:
            return value / 100.0
    
    return None


def parse_iso_date(s: Optional[str]) -> Optional[str]:
    """
    Parsea fecha a formato ISO (YYYY-MM-DD).
    Maneja varios formatos comunes.
    """
    if not s:
        return None
    
    if isinstance(s, str):
        s = s.strip()
        
        # Ya está en formato ISO
        if re.match(r'^\d{4}-\d{2}-\d{2}$', s):
            return s
        
        # Formato DD/MM/YYYY
        if re.match(r'^\d{1,2}/\d{1,2}/\d{4}$', s):
            try:
                dt = datetime.strptime(s, '%d/%m/%Y')
                return dt.strftime('%Y-%m-%d')
            except ValueError:
                pass
        
        # Formato MM/DD/YYYY
        if re.match(r'^\d{1,2}/\d{1,2}/\d{4}$', s):
            try:
                dt = datetime.strptime(s, '%m/%d/%Y')
                return dt.strftime('%Y-%m-%d')
            except ValueError:
                pass
        
        # Formato DD-MM-YYYY
        if re.match(r'^\d{1,2}-\d{1,2}-\d{4}$', s):
            try:
                dt = datetime.strptime(s, '%d-%m-%Y')
                return dt.strftime('%Y-%m-%d')
            except ValueError:
                pass
    
    return None


def file_sha256(path: str) -> str:
    """
    Calcula el hash SHA256 de un archivo.
    """
    sha256_hash = hashlib.sha256()
    try:
        with open(path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
    except (IOError, OSError):
        return ""


def ensure_dirs(*paths: str) -> None:
    """
    Crea directorios si no existen.
    """
    for path in paths:
        if path and not os.path.exists(path):
            os.makedirs(path, exist_ok=True)
